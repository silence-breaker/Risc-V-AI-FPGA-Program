# 1.58-bit (三值化) 大模型硬件加速器开发路径

> 本文档基于现有讨论内容，总结了 1.58-bit 大模型硬件加速器的核心开发逻辑，并制定了从寒假到开学后的详细实施计划。

---

## 一、内容总结

### 1. 项目核心

- **平台选择**：利用 FPGA（如 Zynq 7020）实现硬件加速
- **核心原理**：由于采用 1.58-bit（三值化）权重，复杂的乘法运算可简化为加法或减法，极大地优化了硬件资源消耗和处理速度

### 2. 技术路线

- **先软后硬**：优先在 PC 端（Python）跑通算法，识别性能瓶颈
- **协处理器架构**：不建议初学者从零开发 RISC-V 核心，而是将加速阵列作为协处理器挂载到成熟的 SOC 系统（如 Zynq 自带的 ARM 核）中
- **开发语言**：坚持使用 Verilog/System Verilog 进行底层开发，不建议使用 HLS 或 Chisel，以确保扎实的硬件底层逻辑功底

### 3. 评估目标

- **重点**：功能正确性、相对加速比（硬件加速前 vs 硬件加速后）
- **非重点**：不直接与高性能 PC CPU 进行绝对速度的竞争

---

## 二、下一步计划：寒假期间 (1.16 - 3.1)

> 此阶段重点在于打好算法基础并开始编写核心硬件模块。

### 1. 算法验证与分析 (1月中下旬)

- **环境部署**：在 PC 端（Windows/Linux）部署 1.58-bit 大模型的 Python 源码
- **流程跑通**：确保推理流程能输出正确结果
- **瓶颈拆解**：分析线性层、矩阵乘法等算子的计算占比

### 2. 理论深挖 (1月下旬)

- **原理理解**：彻底搞懂三值化量化权重如何将乘法转为加法的细节
- **架构构思**：根据算法需求，初步设计硬件加速阵列（Array）的并行度与位宽

### 3. 核心硬件模块设计 (2月)

- **Verilog 编写**：开始编写加速阵列模块
- **独立验证**：先不考虑总线，单纯验证阵列在处理特定算子时的逻辑正确性
- **规范化代码**：遵循标准可综合风格（状态机、时序与组合逻辑分离）

---

## 三、下一步计划：寒假之后 (3.1 以后)

> 此阶段重点在于系统集成与整体验证。

### 1. IP 化与接口封装

- **IP 封装**：将加速阵列封装为标准 IP 核
- **接口设计**：设计 AXI 总线接口，确定主机数据传输与结果返回机制

### 2. SOC 系统搭建

- **环境构建**：利用 Zynq 7020 的 ARM 核搭建完整的 SOC 环境
- **挂载调试**：将加速器 IP 挂载到总线上，实现协处理器模式

### 3. 功能与性能测试

- **功能对齐**：对比硬件结果与 Python 仿真结果，确保精度无损
- **量化加速**：测算并对比"纯 CPU 运行"与"CPU + 硬件加速"的时间差异

### 4. 持续优化

- **进阶探索**：在功能正确前提下，优化功耗或尝试 RISC-V 自定义指令集拓展