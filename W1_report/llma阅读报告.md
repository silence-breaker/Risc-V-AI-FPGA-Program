# 拆解 BitNet C++ 源码：从软件裸跑到 FPGA 硬件映射

你好！如果你已经受够了 PyTorch 里“假装是 1-bit 其实还在跑浮点”的龟速，欢迎来到 **C++ 和裸机编程**的真实世界。

在 `microsoft/BitNet`（以及其底座 `llama.cpp`）的 C++ 代码里，没有 Python 那种自动垃圾回收的“保姆”，也没有自动广播机制。在这里，每一块内存都要自己申请，每一个比特的搬运都要精打细算。

这对于 FPGA 工程师来说，简直就是完美的“硬件行为描述书”。让我们分三个模块来拆解它。

---

## 模块一：内存管理（The Warehouse Manager）

在 Python 里，你写 `x = tensor`，系统自动找地方存。但在 C++ 的 BitNet 里，一切都是**手动挡**。
### C++ 里的做法

源码中通过 `ggml` 库（llama.cpp 的核心张量库）实现了一个概念叫 **Context（上下文）**。

1. **预分配大内存**：程序启动时，一次性 `malloc` 申请几 GB 的一大块内存。
    
2. **指针偏移**：所有的权重、中间变量（KV Cache），其实都是这块大内存里的“偏移量”。
    
    - _代码逻辑_：`float* layer1_input = base_ptr + offset_A;`
        
3. **零拷贝加载**：模型文件（GGUF 格式）通过 `mmap` 直接映射到内存，不需要像 PyTorch 那样把硬盘数据读出来再拷进去。
    
### 映射到 FPGA 逻辑

这完全对应 FPGA 上的 **DDR 控制与地址生成器（Address Generator）**：
- **Base Pointer**：对应 FPGA 读写 DDR 的基地址。
- **Offset**：你需要设计一个状态机（FSM），根据层数计算读写地址的偏移。
- **FPGA 启示**：C++ 里随意的“随机访问”（Random Access）在 FPGA 上代价很大。你需要把这些内存访问设计成**Burst Mode（突发模式）**，一次读进来一整行数据。
    
---
## 模块二：比特搬运工（The Bit Packer）

BitNet 的核心是 **1.58 bit**，也就是三元值 `{-1, 0, 1}`。但在计算机里，最小单位是 1 bit，所以物理上我们需要 **2 bit** 来存一个参数（00, 01, 10, 11）。
### C++ 里的做法

源码中有一个关键的步骤叫 **Quantization（量化/打包）** 和 **De-quantization（解包）**。
- **打包（Packing）**：为了节省内存带宽，C++ 不会用 8-bit 的 `char` 去存这 2-bit 的数，而是把 4 个参数塞进一个 8-bit 的字节里。
    - _代码逻辑_：`packed_byte = (w0 << 6) | (w1 << 4) | (w2 << 2) | w3;`
- **解包（Unpacking）**：在计算前，CPU 需要用位运算把它们取出来。
    
### 映射到 FPGA 逻辑

这是 FPGA 最擅长的地方！
- **Bus Width（总线位宽）**：CPU 只有 64-bit 总线，一次读 32 个参数。你的 FPGA 可以设计 512-bit 甚至 1024-bit 的宽总线。
    
- **无需解包**：在 FPGA 里，你**不需要**像 C++ 那样费劲地写“解包代码”。你可以直接把这 512-bit 的线撕开，变成 256 组 2-bit 的信号线，直接喂给计算模块。
    
- **FPGA 启示**：C++ 里为了解包消耗的 CPU 周期，在 FPGA 上是 **0 开销**（纯连线操作）。
    
---
## 模块三：计算核心（The Adder, Not Multiplier）

这是 BitNet 最迷人的地方。也是源码中 `BitLinear`（位线性层）的核心。
### C++ 里的做法

传统的矩阵乘法是 Y = W * X，涉及大量的浮点乘法。

但在 BitNet C++ 源码里，你会发现核心循环变了。因为权重 $W$ 只有 $\{-1, 0, 1\}$：

- 如果 $W = 1$：`sum += input` （加法）
    
- 如果 $W = -1$：`sum -= input` （减法）
    
- 如果 $W = 0$：`continue` （跳过/不操作）
    
**源码逻辑（伪代码）：**
C++
```
// 传统的乘法
// sum += weight[i] * input[i]; 

// BitNet 的逻辑 (极速版)
if (weight[i] == 1)      sum += input[i];
else if (weight[i] == -1) sum -= input[i];
// 0 的情况直接忽略
```

这就把昂贵的“乘法”变成了极低成本的“加减法”。在 CPU 上，他们会使用 SIMD 指令（AVX2/AVX512）来并行处理这些加减。

### 映射到 FPGA 逻辑

这对应 FPGA 上的 **累加器树（Accumulator Tree）** 或 **Systolic Array（脉动阵列）** 的简化版。
- **DSP Slices 的解放**：FPGA 里的 DSP 资源（乘法器）非常宝贵。普通大模型会把 DSP 耗尽。但 BitNet **不需要乘法器**！
- **LUT 实现**：你只需要用查找表（LUT）搭建加法器和减法器。这意味着你可以在一块中端 FPGA 上堆叠出海量的并行计算单元。
- **Mux 逻辑**：
    - 输入：`Input_Data` (FP16/INT8), `Weight` (2-bit)
        
    - 逻辑：一个简单的多路选择器（Mux）。
        
        - Weight=01 -> 输出 `Input_Data`
            
        - Weight=10 -> 输出 `-Input_Data` (补码)
            
        - Weight=00 -> 输出 `0`
            
    - 输出 -> 进加法树。
---
## 总结：从源码到电路的蓝图

当你阅读 `microsoft/BitNet` 的源码时，请戴上“电路设计师”的眼镜：

|**C++ 源码概念**|**FPGA 对应模块**|**优势分析**|
|---|---|---|
|**`malloc` / 指针偏移**|**DDR 控制器 / 地址生成逻辑**|FPGA 需处理数据对齐，不如 CPU 灵活，但带宽更高。|
|**位运算 (`<<`, `&`) 打包**|**总线分裂 (Bus Splitting)**|FPGA 完胜，纯物理连线，零延迟。|
|**`for` 循环遍历**|**流水线 (Pipelining)**|将串行循环展开为并行流水线，吞吐量暴增。|
|**`if (w==1) add`**|**多路选择器 + 加法器**|摆脱对 DSP 的依赖，极大降低功耗和面积。|

下一步建议：

去源码里找 ggml-quants.c 或类似的量化内核文件，看看它是如何定义 vec_dot（向量点积）函数的。你会发现那里没有乘号 *，只有位操作和加减号。那就是你要在 Verilog/HLS 里复现的核心逻辑！